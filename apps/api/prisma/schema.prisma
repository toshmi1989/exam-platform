generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ExamType {
  TEST
  ORAL
}

enum ExamProfession {
  DOCTOR
  NURSE
}

enum ExamLanguage {
  UZ
  RU
}

enum AttemptMode {
  EXAM
  PRACTICE
}

enum QuestionType {
  TEST
  ORAL
}

enum AttemptStatus {
  CREATED
  IN_PROGRESS
  SUBMITTED
  COMPLETED
  EXPIRED
}

enum UserRole {
  USER
  ADMIN
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
}

model Category {
  id    String @id @default(cuid())
  name  String @unique
  exams Exam[]
}

model Exam {
  id                String   @id @default(cuid())
  title             String
  type              ExamType
  profession        ExamProfession
  language          ExamLanguage
  direction         String
  categoryId        String
  /** Группа пары направлений при импорте: чётный и нечётный лист (UZ+RU) получают один и тот же id. Нужно для удаления «направления» обоими языками. */
  directionGroupId  String?
  timeLimitSeconds  Int      @default(1800)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  category      Category          @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  questions     Question[]
  oralSessions  OralExamSession[]

  @@unique([title, categoryId])
  @@index([categoryId])
  @@index([profession, language])
  @@index([directionGroupId])
}

model Question {
  id              String        @id @default(cuid())
  examId          String
  type            QuestionType
  prompt          String
  explanationHtml String?
  order           Int?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  aiExplanationRu String?
  aiExplanationUz String?
  aiGeneratedAt  DateTime?

  exam          Exam                     @relation(fields: [examId], references: [id], onDelete: Cascade)
  options       QuestionOption[]
  oralAnswer    OralAnswer?
  aiExplanations QuestionAIExplanation[]
  audioScripts  QuestionAudioScript[]
  audios        QuestionAudio[]

  @@index([examId])
}

model QuestionAIExplanation {
  id         String   @id @default(uuid())
  questionId String   @unique
  lang       String
  hash       String
  content    String
  createdAt  DateTime @default(now())

  Question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

model QuestionAudioScript {
  id         String   @id @default(uuid())
  questionId String
  lang       String
  content    String   @db.Text
  hash       String
  createdAt  DateTime @default(now())

  Question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([questionId, lang])
  @@index([questionId])
}

model QuestionAudio {
  id         String   @id @default(uuid())
  questionId String
  lang       String
  audioPath  String
  createdAt  DateTime @default(now())

  Question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([questionId, lang])
  @@index([questionId])
}

model TtsSettings {
  id           String   @id @default(cuid())
  rate         Int      @default(0)
  pauseMs      Int      @default(500)
  ssmlTemplate String   @db.Text
  enabled      Boolean  @default(true)
  voiceRu      String?  // e.g. ru-RU-SvetlanaNeural
  voiceUz      String?  // e.g. uz-UZ-MadinaNeural
  updatedAt    DateTime @default(now()) @updatedAt
}

model QuestionOption {
  id         String   @id @default(cuid())
  questionId String
  label      String
  isCorrect  Boolean  @default(false)
  order      Int?

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

model OralAnswer {
  id         String  @id @default(cuid())
  questionId String  @unique
  answerHtml String

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

/** Один ответ на один и тот же текст вопроса внутри направления (между категориями). Экономит токены: одинаковые вопросы в 1-й и 3-й категории делят один сгенерированный ответ. */
model DirectionOralAnswer {
  id         String   @id @default(cuid())
  direction  String
  language   String   // RU | UZ
  promptHash String
  answerHtml String   @db.Text
  createdAt  DateTime @default(now())

  @@unique([direction, language, promptHash])
  @@index([direction, language, promptHash])
}

model ImportBatch {
  id         String   @id @default(cuid())
  sourceFile String?
  createdAt  DateTime @default(now())
  stats      Json?
}

model ExamAttempt {
  id          String        @id
  userId      String
  examId      String
  status      AttemptStatus
  mode        AttemptMode   @default(EXAM)
  questionIds String[]      @default([])
  answers     Json
  createdAt   DateTime @default(now())
  startedAt   DateTime?
  expiresAt   DateTime?
  submittedAt DateTime?
  score       Int?
  maxScore    Int?

  @@index([userId])
  @@index([examId])
}

model User {
  id                     String   @id
  telegramId             String   @unique
  firstName              String?
  username               String?
  role                   UserRole @default(USER)
  acceptedTerms          Boolean  @default(false)
  acceptedAt             DateTime?
  agreementVersion       String?
  dismissedBroadcastIds  String[]  @default([])
  telegramBlocked        Boolean  @default(false)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  oralSessions OralExamSession[]
  sttUsageLogs  SttUsageLog[]
}

model SttUsageLog {
  id        String   @id @default(cuid())
  userId    String
  success   Boolean  // true = transcript ok, false = STT error
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model UserSubscription {
  id        String             @id @default(cuid())
  userId    String
  startsAt  DateTime           @default(now())
  endsAt    DateTime
  status    SubscriptionStatus @default(ACTIVE)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@index([userId])
  @@index([endsAt])
  @@index([userId, status, endsAt])
}

model OneTimeAccess {
  id            String   @id @default(cuid())
  userId        String?  // null if guestSessionId is set
  guestSessionId String? @unique // null if userId is set
  examId        String
  consumedAt    DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([guestSessionId])
  @@index([examId])
  @@index([consumedAt])
  @@unique([userId, examId, consumedAt])
  @@unique([guestSessionId, examId, consumedAt])
}

model AccessSettings {
  id                          String  @id
  subscriptionPrice           Int
  subscriptionDurationDays    Int
  allowFreeAttempts           Boolean
  freeDailyLimit              Int
  freeOralDailyLimit          Int     @default(5)
  botAiDailyLimitFree         Int     @default(3)
  showAnswersWithoutSubscription Boolean
  oneTimePrice                Int
  showAnswersForOneTime        Boolean
  plan1Name                   String? @default("Подписка")
  plan1Price                  Int?    @default(99000)
  plan1DurationDays           Int?    @default(30)
  plan1Enabled                Boolean? @default(true)
  plan2Name                   String?
  plan2Price                  Int?    @default(0)
  plan2DurationDays            Int?    @default(0)
  plan2Enabled                Boolean? @default(false)
  plan3Name                   String?
  plan3Price                  Int?    @default(0)
  plan3DurationDays           Int?    @default(0)
  plan3Enabled                Boolean? @default(false)
  updatedAt                   DateTime @updatedAt
}

model BotAiRequestLog {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model OralAccessLog {
  id         String   @id @default(cuid())
  userId     String
  questionId String?  // один слот = один просмотренный ответ на вопрос в день (по разным questionId)
  createdAt  DateTime @default(now())

  @@index([userId, createdAt])
  @@index([userId, questionId, createdAt])
}

model PaymentInvoice {
  id            String    @id @default(cuid())
  invoiceId     String    @unique
  userId        String?   // null if guestSessionId is set
  guestSessionId String?  // null if userId is set
  kind          String
  examId        String?
  amountTiyin   Int
  ps            String
  status        String    @default("created")
  mcUuid        String?
  subscriptionDurationDays Int?  // for subscription: days to add when paid
  subscriptionPlanName       String? // for subscription: plan label for display
  createdAt     DateTime  @default(now())
  paidAt        DateTime?

  @@index([userId])
  @@index([guestSessionId])
  @@index([invoiceId])
  @@index([status])
}

model KnowledgeBaseEntry {
  id        String   @id @default(uuid())
  title     String
  source    String
  content   String
  embedding Json
  createdAt DateTime @default(now())
}

model BotAnswerCache {
  id           String   @id @default(uuid())
  questionHash String   @unique
  answer       String
  createdAt    DateTime @default(now())
}

/** Вопросы, на которые бот не нашёл ответ (noAnswerFound). Для анализа и пополнения базы знаний по темам. */
model BotUnansweredQuestion {
  id           String   @id @default(cuid())
  questionText String   @db.Text
  telegramId   String?
  topic        String?  // тема: Сертификат, Подписка, Вход, Устный экзамен, Другое...
  createdAt    DateTime @default(now())

  @@index([topic])
  @@index([createdAt])
}

model ZiyodaPrompt {
  id    String @id @default(cuid())
  key   String @unique
  value String @db.Text
}

model OralExamSession {
  id          String    @id @default(cuid())
  userId      String
  examId      String
  startedAt   DateTime  @default(now())
  finishedAt  DateTime?
  score       Int?
  maxScore    Int?
  status      String    @default("active") // active | finished | timeout
  questionIds String[]

  user    User             @relation(fields: [userId], references: [id])
  exam    Exam             @relation(fields: [examId], references: [id], onDelete: Cascade)
  answers OralExamAnswer[]

  @@index([userId, status])
  @@index([examId])
}

model OralExamAnswer {
  id               String   @id @default(cuid())
  sessionId        String
  questionId       String
  transcript       String?
  score            Int?
  detailedFeedback Json?
  createdAt        DateTime @default(now())

  session OralExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([questionId])
}
